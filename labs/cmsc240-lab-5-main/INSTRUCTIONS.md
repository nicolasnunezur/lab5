# Lab 5 - An AI Adventure (2 PERSON ASSIGNMENT)

## Overview

Now that you have made a fun and functional game, it's time to get an AI to play it! This "AI" is actually a random agent -- it spits out random commands into the game until it wins. Unfortunately, it's not very efficient. That's where you come in.

To make this agent more efficient at solving your game, you are going to prune the commands down using natural language processing, pattern recognition, and state space searches. This will reduce the agent's "guesses" into a shorter more refined solution.

You are going to write code that reduces the agent's solutions for 2 different games: your game and your partner's game. **The pruned solution from the random AI commands should be no more than 7 times more steps than your ideal solution (as specified from your README in Lab #4).**

## Starter Code

This lab has a *LOT* of starter code.

### [solution_generator.py](solution_generator.py) 
This script will attempt to solve the game and create a new solution log once it finds a solution. You can modify the parameters to increase solution length and the number of attempts. Run this code to create a new solution file for your games. The resulting file will be called `AI-[GAME NAME].log`.
        ```
            Usage: python solution_generator.py <GAME PROGRAM> <max command inputs> <max attempts>
            Example: python solution_generator.py ./nyc_trip 200 10
        ```

### [ai_utils.cpp and utils.h](utils.cpp)
These are starter functions and structures you will use for parsing the log files generated by [solution_generator.py] and for developing your pruning code. 
    - The function `parseGameIO` will automatically read in the log file based on the game name provided and return a vector of objects from the `gameIO` struct. The members of the struct are `input`, which is a string of input command used, and `output` which is a vector of strings for the following output before the next command.  
    - The function `isNovel` will check if an object of the structure `gameState` is different from a vector of other gameStates. the `gameState` structure has members that detail the current state of the game's inventory, location, command input, and the text description output. You can use this struct to keep track of the player's progress, but you'll have to set the member values yourself.
    
    **You are free to change any part of these C++ files and modify them as needed**

### [ai_parser.cpp](ai_parser.cpp)
This is where you will be writing the main functionality of your code. The example code takes in the `AI-[GAME NAME].log` generated by [solution_generator.py] and converts them into `gameIO` struct with `parseGameIO`. Below this, you will write your pruning algorithm that will reduce the original log file to a shorter output of commands to still solve the game. These commands will be saved to the vector `best_commands`. After the best commands have been found, the program will output the vector line by line to a new file called `<GAME NAME>.solution`. Use this solution file to check to make sure the game can still be succesfully solved.

**You are NOT allowed to hard-code the parser to write the ideal solution to the .solution file and must use the commands from the generated log**


### [solution_check.py](solution_check.py)
This will check if a `.solution` file with a list of commands will successfully solve a game. Just provide the name of the game prgram and it will automatically use the associated `.solution` file with it (e.g. `<GAME NAME>.solution`).
        ```
            Usage: python solution_check.py <GAME PROGRAM>
            Example: python solution_check.py ./nyc_trip        # reads in the `nyc_trip.solution`
        ```

## Setup

1. Add the executables for both games from Lab #4 to this repository. *DO NOT MODIFY THE GAMES' SOURCE CODE AFTER THIS POINT*
2. For each game, create a new file called `<GAME NAME>.inputs`. In this file list every possible command that can be done in your game (e.g. 'help', 'show map', 'show inventory', 'get [item]', 'use [item]', 'goto [location]'). Make sure you have EVERY command
3. Run `python solution_generator.py <GAME NAME>` with the associated game. This will create a new log file called `AI-[GAME NAME].log`. Increase the `max command inputs` and `max attempts` parameters if needed.
4. Write your pruning code in `ai_parser.cpp` to reduce the log commands down to fewer steps. This should create a new file with a list of commands called `<GAME NAME>.solution`
5. Check the output solution by running `python solution_check.py <GAME NAME>` to make sure your pruned solution is still succesful at solving the game.


## Code Requirements

1. Each function in your code should have description of the function as a comment directly under the function name. It should also include descriptions of what each parameter does in the code. 

2. At the top of the program with the `int main()` function (your main code), write in a header documentation comment your name, your partner's name, your two game names, the class and section number, the date, and the program description.

## Makefile

You are also required to have a Makefile for your game. The Makefile must include 2 targets: 
    1. `all` - which *makes all of the targets* (except `clean`) in the game
    2. `clean` - which removes any object files (.o) and removes the executable game file

You can create additional targets as needed for the files and build targets in your game.

## README.md

Make a README.md file 
- One section that includes your name, your partner's name, the date, and a program description. 
- One section should include details on how to compile your program for both games (i.e. if there are command line arguments to change the game or a Makefile target to run.) 
- One section with the ideal solutions (in command form) to both games
- One section briefly explaining  how your pruning algorithm works (what do you remove, what do you search for.) [Maximum 500 words.]

## Rules

- You are allowed to use any resource so long as it follows the course syllabus and any external resource is cited in both the code (as a comment) and the README.md file.
- *NO VIBE CODING!* If you use an AI resource (e.g. Github Copilot, ChatGPT) cite it and provide a chat conversation link if possible.
- Only built-in libraries are allowed. Your program should not and cannot use anything that must be installed from an external source.

- You are allowed to create as many files as you want.
- You are allowed to modify any part of the Makefile and add more targets or change targets if needed.
- You are allowed to modify any of the C++ code. 
- **DO NOT modify the provided Python files!**

## Example Game [NYC TRIP]

Some sample generations and solutions are provided for you using the original nyc_trip game from Lab #4

- [AI-nyc_trip.log](AI-nyc_trip.log) -- The generated random AI log from [solution_generator.py](solution_generator.py) (feel free to run it again to make a new log and test your pruner!)
- [nyc_trip.inputs](nyc_trip.inputs) -- The list of all possible commands that can be used in the game (NOTE: Even if they show up as [INVALID COMMAND] if attempted in the wrong context of the game.)
- [nyc_trip.solution-IDEAL](nyc_trip.solution-IDEAL) -- The shortest possible solution to beat the game
- [nyc_trip.solution-EXAMPLE](nyc_trip.solution-EXAMPLE) -- A solution created from the generated log (AI-nyc_trip.log) that was pruned down by ai_parser.cpp

*To run the solution_check.py code on the .solution files and see that they are still successful to beat the game, remove the `-IDEAL` and the `-EXAMPLE` from the extension.*

## HINTS

- Skip any commands that return an [INVALID COMMAND] error in your game
- Use the `help`, `show inventory`, and `show map` commands (if they're called) to keep track of the player's available commands, current inventory, and location.
- Use Regex to grab the player's current location from the output
- You don't have to include `help`, `show inventory`, and `show map`  in the best command output since they don't influence the game.
- Check if the game state has already been seen by keeping track of a list of `gameState` structs. If it has, it probably isn't a very useful command.

## Rubric ( 100 Points total )

** Your program must work for both games and for ANY randomly generated solution file made from [solution_generator.py](solution_generator.py). The pruned solution from the random AI commands should be no more than 7 times more steps than your ideal solution (as specified from your README in Lab #4). For example, if you ideal solution runs in 10 commands -- the pruned solution can be no more than 70 commands **

### Algorithm

| Points | Criteria |
| :----: | :------- |
| **30 pts** | `ai_parser.cpp` produces a solution file that is no more than 7x the ideal solution (15 pts for both games) |
| **20 pts** | Code is not hard-coded to find or generate the ideal solution and uses the randomly made log file to parse through commands (no partial credit) |
| **10 pts** | Code runs without errors |

**(60 points total)**


### Code

| Points | Criteria |
| :----: | :------- |
| **5 pts** | Names, date, game names, and program description |
| **5 pts** | Code thoroughly documented (functions have comments and describe what they do, properly named variables, good coding etiquette) |
| **10 pts** | Both game's functionalities are unchanged from Lab #3 |

**(20 points total)**


### README.md

| Points | Criteria |
| :----: | :------- |
| **5 pts** | Section with name, date, game names, and program description |
| **5 pts** | Section on how to compile the program |
| **5 pts** | Section providing the ideal solutions to both games |
| **5 pts** | Section on how the pruning algorithm works to create the solution from the AI log files |

**(20 points total)**
